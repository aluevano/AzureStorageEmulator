using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace AsyncHelper
{
	[DebuggerStepThrough]
	public class AsyncIteratorContextBase : AsyncResultBase
	{
		private IEnumerator<IAsyncResult> iterator;

		internal AsyncCallTracker Caller
		{
			get
			{
				return base.AsyncState as AsyncCallTracker;
			}
		}

		public AsyncIteratorContextBase(string methodName, AsyncCallback callback, object state) : base(methodName, callback, state)
		{
		}

		public void Begin(IEnumerator<IAsyncResult> iterator)
		{
			if (iterator == null)
			{
				throw new ArgumentNullException("iterator");
			}
			this.iterator = iterator;
			this.ExecuteIterator(true);
		}

		[SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification="This method needs to catch Exception, or it will terminate the process whenever an iterator throws.")]
		private void ExecuteIterator(bool inBegin)
		{
			Exception exception = null;
			try
			{
				if (!inBegin)
				{
					Tracing.TraceSource.TraceData(TraceEventType.Resume, 0, this);
				}
				else
				{
					Tracing.TraceSource.TraceData(TraceEventType.Start, 0, this);
				}
				while (this.iterator.MoveNext())
				{
					AsyncCallTracker asyncCallTracker = this.TrackerFromAsyncResult(this.iterator.Current);
					Tracing.TraceSource.TraceData(TraceEventType.Suspend, 0, asyncCallTracker);
					if (!asyncCallTracker.Wait())
					{
						return;
					}
					else
					{
						Tracing.TraceSource.TraceData(TraceEventType.Resume, 0, this);
					}
				}
			}
			catch (Exception exception1)
			{
				exception = exception1;
			}
			try
			{
				try
				{
					this.iterator.Dispose();
				}
				catch (Exception exception2)
				{
					exception = exception2;
				}
			}
			finally
			{
				this.iterator = null;
			}
			Tracing.TraceSource.TraceEvent(TraceEventType.Stop, 0, base.MethodName);
			base.InternalComplete(exception, inBegin);
		}

		[SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
		public AsyncCallback GetResumeCallback()
		{
			return new AsyncCallback(this.OnResumeCallback);
		}

		public object GetResumeState(string calleeName)
		{
			return new AsyncCallTracker(calleeName, this);
		}

		private void OnResumeCallback(IAsyncResult asyncResult)
		{
			this.TrackerFromAsyncResult(asyncResult).IndicateCallComplete();
		}

		internal void ResumeExecution()
		{
			this.ExecuteIterator(false);
		}

		public override string ToString()
		{
			return base.MethodName;
		}

		private AsyncCallTracker TrackerFromAsyncResult(IAsyncResult asyncResult)
		{
			AsyncCallTracker asyncState = asyncResult.AsyncState as AsyncCallTracker;
			if (asyncState == null)
			{
				throw new InvalidOperationException(string.Concat("Async iterator ", base.MethodName, " made an async call without passing the result of AsyncIteratorContext.ResumeContext as the call's state parameter."));
			}
			if (!object.ReferenceEquals(asyncState.Caller, this))
			{
				string[] methodName = new string[] { "Async iterator ", base.MethodName, " made an async call to ", asyncState.CalleeName, " using an async state that was not generated by the associated AsyncIteratorContext object." };
				throw new InvalidOperationException(string.Concat(methodName));
			}
			return asyncState;
		}
	}
}